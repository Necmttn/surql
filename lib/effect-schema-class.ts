import type { TableDefinition } from "./schema.ts";

/**
 * Format a table name as a class name
 */
function formatClassName(tableName: string): string {
	return tableName.charAt(0).toUpperCase() + tableName.slice(1);
}

/**
 * Generate Effect Model classes from SurrealDB table definitions
 */
export function generateEffectSchemas(tables: TableDefinition[]): string {
	// Prepare imports
	const imports = `/**
 * ⚠️ AUTO-GENERATED FILE ⚠️
 * This file is automatically generated. Do not modify it manually.
 * Any changes made to this file will be overwritten when regenerating.
 * 
 * Generated by: @necmttn/surql
 * Date: ${new Date().toISOString()}
 */

// Effect Schema Class API integration for SurrealDB types
import { Schema } from "effect";
import { RecordId, StringRecordId } from "surrealdb";

export const stringRecordIdSchema = <T extends string>(tableName: T) => Schema.transform(
  recordIdLiteral(tableName),
  Schema.instanceOf(StringRecordId),
  {
    strict: true,
    decode: (from: \`\${T}:\${string}\`) => {
      return new StringRecordId(from);
    },
    encode: (to) => {
      return to.toString() as \`\${T}:\${string}\`;
    },
  }
);

export const recordIdSchema = <T extends string>(tableName: T) => Schema.transform(
  recordIdLiteral(tableName),
  Schema.instanceOf(RecordId),
  {
    strict: true,
    decode: (from: \`\${T}:\${string}\`) => {
      const [table, id] = from.split(":");
      if (!table || !id) {
        throw new Error(\`Invalid RecordId: \${ from } \`);
      }
      return new RecordId(table, id);
    },
    encode: (to) => {
      return to.toString() as \`\${T}:\${string}\`;
    },
  }
);

export const recordIdLiteral = <T extends string>(tableName: T) =>
  Schema.TemplateLiteral(
    Schema.Literal(tableName),
    Schema.Literal(":"),
    Schema.String,
  );

/**
 * Create a RecordId schema for a specific table
 */
export function recordId<T extends string>(tableName: T) {
	return Schema.Union(
		recordIdSchema(tableName),
		stringRecordIdSchema(tableName),
	);
}
`;

	// Generate table classes
	const tableClasses = tables
		.map((table) => {
			const { name, fields, description } = table;
			const className = formatClassName(name);

			// Check if table already has an 'id' field
			const hasIdField = fields.some((field) => field.name === "id");

			// Create a map to organize nested fields
			const nestedFieldsMap = new Map<string, Array<{ path: string[]; field: any }>>();

			// First pass: identify and group nested fields
			// biome-ignore lint/complexity/noForEach: <explanation>
			fields.forEach(field => {
				const fieldNameParts = field.name.split('.');
				if (fieldNameParts.length > 1 && fieldNameParts[0]) {
					// This is a nested field
					const rootField = fieldNameParts[0];
					if (!nestedFieldsMap.has(rootField)) {
						nestedFieldsMap.set(rootField, []);
					}
					nestedFieldsMap.get(rootField)?.push({
						path: fieldNameParts.slice(1),
						field
					});
				}
			});

			// Create a list of field definitions
			let fieldDefinitions: string[] = [];

			// Add default 'id' field if not explicitly defined
			if (!hasIdField) {
				fieldDefinitions.push(`  id: recordId("${name}")`);
			}

			// Process non-nested fields first
			const processedFields = new Set<string>();
			// biome-ignore lint/complexity/noForEach: <explanation>
			fields.forEach(field => {
				const fieldNameParts = field.name.split('.');
				const rootFieldName = fieldNameParts[0];

				if (!rootFieldName) return;

				// If this is a nested field, skip it
				if (field.name.includes('.')) return;

				// If this is a root field that has nested fields, we'll process it separately
				if (nestedFieldsMap.has(rootFieldName)) {
					processedFields.add(rootFieldName);
				}
				// Otherwise process it as a normal field
				else {
					processedFields.add(field.name);
					const fieldDef = generateFieldDefinition(field, tables);
					fieldDefinitions.push(`  ${field.name}: ${fieldDef}`);
				}
			});

			// Process nested fields
			nestedFieldsMap.forEach((nestedFields, rootField) => {
				// We need to find the root field definition
				const rootFieldDef = fields.find(f => f.name === rootField) || {
					name: rootField,
					type: 'object',
					optional: true
				};

				// Create the nested schema structure
				const nestedSchema = generateNestedSchema(rootFieldDef, nestedFields, tables);
				fieldDefinitions.push(`  ${rootField}: ${nestedSchema}`);
			});

			const tableDescription = description
				? `\n/**\n * ${(description || '').replace(/'/g, "\\'")}\n */`
				: "";

			return `${tableDescription}
export namespace ${className} {
  export const Fields = {
	${fieldDefinitions.join(",\n  ")}
  };

  export class ${className} extends Schema.Class<${className}>("${className}")({
    ...Fields,
  }) {
    static readonly tableName = "${name}" as const;
  }

	export type Type = Schema.Schema.Type<typeof ${className}>;

  export const update = Schema.Struct({
		...Object.fromEntries(
			Object.entries(Fields).map(([key, schema]) => [
				key,
				Schema.optional(schema as Schema.Any),
			]),
		),
		id: recordId("${name}"),
	});
}`;
		})
		.join("\n");

	return `${imports}\n${tableClasses}`;
}

/**
 * Generate a nested schema structure for nested fields
 */
function generateNestedSchema(rootField: any, nestedFields: Array<{ path: string[]; field: any }>, tables: TableDefinition[]): string {
	// Build a tree-like structure of the nested fields
	const fieldTree: Record<string, any> = {};

	// biome-ignore lint/complexity/noForEach: <explanation>
	nestedFields.forEach(({ path, field }) => {
		let current = fieldTree;
		for (let i = 0; i < path.length; i++) {
			const segment = path[i];
			if (!segment) continue;

			if (i === path.length - 1) {
				// Leaf node - store the field definition
				const leafField = { ...field };
				leafField.name = segment;
				current[segment] = leafField;
			} else {
				// Internal node - create or get the subtree
				if (!current[segment]) {
					current[segment] = {};
				}
				current = current[segment];
			}
		}
	});

	// Generate Schema.struct() for the nested structure
	function buildSchemaStruct(tree: Record<string, any>): string {
		const fields: string[] = [];

		for (const key in tree) {
			if (!key) continue;

			if (typeof tree[key] === 'object') {
				if (!tree[key].type) {
					// This is a nested structure
					fields.push(`    ${key}: ${buildSchemaStruct(tree[key])}`);
				} else {
					// This is a field definition
					const fieldDef = generateFieldDefinition(tree[key], tables);
					fields.push(`    ${key}: ${fieldDef}`);
				}
			}
		}

		return `Schema.Struct({\n${fields.join(',\n')}\n  })`;
	}

	// Generate the base schema
	let baseSchema = buildSchemaStruct(fieldTree);

	// Apply annotations if available
	const annotations: string[] = [];

	if (rootField.description) {
		const escapedDescription = (rootField.description || '')
			.replace(/\\'/g, "'")
			.replace(/'/g, "\\'");
		annotations.push(`description: '${escapedDescription}'`);
	}

	// Add default value if available
	if (rootField.defaultValue) {
		let formattedDefaultValue = rootField.defaultValue || '';

		if (formattedDefaultValue.includes("::")) {
			annotations.push(`surrealDefault: '${formattedDefaultValue}'`);
		} else {
			if (
				!formattedDefaultValue.startsWith("'") &&
				!formattedDefaultValue.startsWith('"') &&
				formattedDefaultValue !== "true" &&
				formattedDefaultValue !== "false" &&
				!/^-?\d+(\.\d+)?$/.test(formattedDefaultValue) &&
				!formattedDefaultValue.startsWith("[") &&
				!formattedDefaultValue.startsWith("{")
			) {
				formattedDefaultValue = `'${formattedDefaultValue}'`;
			}

			annotations.push(`default: ${formattedDefaultValue}`);
		}
	}

	const annotationsStr = annotations.length > 0
		? `.annotations({ ${annotations.join(", ")} })`
		: "";

	// Apply optional if needed
	let schema = `${baseSchema}${annotationsStr}`;

	if (rootField.optional) {
		schema = `Schema.optional(${schema})`;
	}

	return schema;
}

/**
 * Generate a field definition for a given field
 */
function generateFieldDefinition(field: any, tables: TableDefinition[]): string {
	const annotations: string[] = [];

	// Add description if available
	if (field.description) {
		const escapedDescription = (field.description || '')
			.replace(/\\'/g, "'")
			.replace(/'/g, "\\'");
		annotations.push(`description: '${escapedDescription}'`);
	}

	// Add default value if available
	if (field.defaultValue) {
		let formattedDefaultValue = field.defaultValue || '';

		// Handle SurrealDB function calls (like time::now())
		if (formattedDefaultValue.includes("::")) {
			// For datetime fields with SurrealDB functions, we'll add it as a separate annotation
			if (field.type && field.type.toLowerCase() === "datetime") {
				annotations.push(`surrealDefault: '${formattedDefaultValue}'`);
			} else {
				formattedDefaultValue = `'${formattedDefaultValue}'`;
				annotations.push(`default: ${formattedDefaultValue}`);
			}
		} else {
			// If it's a simple string with quotes, keep as is
			// If it's a boolean or number, keep as is
			// If it's a string that's not already quoted, add quotes
			if (
				!formattedDefaultValue.startsWith("'") &&
				!formattedDefaultValue.startsWith('"') &&
				formattedDefaultValue !== "true" &&
				formattedDefaultValue !== "false" &&
				!/^-?\d+(\.\d+)?$/.test(formattedDefaultValue) &&
				!formattedDefaultValue.startsWith("[") &&
				!formattedDefaultValue.startsWith("{")
			) {
				formattedDefaultValue = `'${formattedDefaultValue}'`;
			}

			annotations.push(`default: ${formattedDefaultValue}`);
		}
	}

	// Build annotations string
	const annotationsStr = annotations.length > 0
		? `.annotations({ ${annotations.join(", ")} })`
		: "";

	let effectType: string;
	const fieldType = field.type ? field.type.toLowerCase() : 'string';

	switch (fieldType) {
		case "int":
		case "number":
			effectType = `Schema.Number.pipe(Schema.int())${annotationsStr}`;
			break;
		case "float":
			effectType = `Schema.Number${annotationsStr}`;
			break;
		case "bool":
			effectType = `Schema.Boolean${annotationsStr}`;
			break;
		case "datetime":
			effectType = `Schema.DateFromSelf${annotationsStr}`;
			break;
		case "array":
			effectType = `Schema.Array(Schema.Unknown)${annotationsStr}`;
			break;
		case "array<float>":
		case "array<number>":
			effectType = `Schema.Array(Schema.Number)${annotationsStr}`;
			break;
		case "array<int>":
			effectType = `Schema.Array(Schema.Number.pipe(Schema.int()))${annotationsStr}`;
			break;
		case "array<bool>":
			effectType = `Schema.Array(Schema.Boolean)${annotationsStr}`;
			break;
		case "array<datetime>":
			effectType = `Schema.Array(Schema.DateFromSelf)${annotationsStr}`;
			break;
		case "array<object>":
			effectType = `Schema.Array(Schema.Unknown)${annotationsStr}`;
			break;
		case "array<record>":
			if (field.reference?.table) {
				const refTableClassName = formatClassName(
					field.reference.table
				);
				// effectType = `Schema.Array(Schema.Union(recordId("${field.reference.table}"), Schema.suspend((): Schema.Schema<${refTableClassName}> => ${refTableClassName})))${annotationsStr}`;
				effectType = `Schema.Array(recordId("${field.reference.table}"))${annotationsStr}`;
			} else {
				effectType = `Schema.Array(Schema.instanceOf(RecordId))${annotationsStr}`;
			}
			break;
		case "array<string>":
			effectType = `Schema.Array(Schema.String)${annotationsStr}`;
			break;
		case "object":
			effectType = `Schema.Unknown${annotationsStr}`;
			break;
		case "record":
			if (field.reference?.table) {
				const refTableClassName = formatClassName(
					field.reference.table
				);
				// effectType = `Schema.Union(recordId("${field.reference.table}"), Schema.suspend((): Schema.Schema<${refTableClassName}> => ${refTableClassName}))${annotationsStr}`;
				effectType = `recordId("${field.reference.table}")${annotationsStr}`;
			} else {
				if (field.name === 'source') {
					console.log("field.reference", JSON.stringify(field, null, 2));
				}
				effectType = `Schema.instanceOf(RecordId)${annotationsStr}`;
			}
			break;
		case "references":
			if (field.reference?.table) {
				const refTableClassName = formatClassName(
					field.reference.table
				);
				// effectType = `Schema.Array(Schema.Union(recordId("${field.reference.table}"), Schema.suspend((): Schema.Schema<${refTableClassName}> => ${refTableClassName})))${annotationsStr}`;
				effectType = `Schema.Array(recordId("${field.reference.table}"))`;
			} else {
				effectType = `stringRecordIdSchema${annotationsStr}`;
			}
			break;
		default:
			effectType = `Schema.String${annotationsStr}`;
			break;
	}

	if (field.optional) {
		effectType = `Schema.optional(${effectType})`;
	}

	return effectType;
}
